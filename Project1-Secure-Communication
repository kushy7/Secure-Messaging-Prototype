# Project 1 - Secure Communication Prototype

import hashlib
import secrets
import time
from typing import Dict, Tuple
import hmac

# Variables for key sizes and options
RSA_BITS = 2048
DH_BITS = 2048          


# Math helpers for prime number generation, RSA, and DH
def egcd(a: int, b: int) -> Tuple[int, int, int]:
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def modinv(a: int, m: int) -> int:
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError("modinv does not exist")
    return x % m

def _decompose(n: int) -> Tuple[int, int]:
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    return r, d

def _is_probable_prime(n: int, rounds: int = 16) -> bool:
    if n < 2: return False
    small = [2,3,5,7,11,13,17,19,23,29]
    if n in small: return True
    if any(n % p == 0 for p in small): return False
    r, d = _decompose(n)
    for _ in range(rounds):
        a = secrets.randbelow(n - 3) + 2
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def _random_odd_integer(bits: int) -> int:
    x = secrets.randbits(bits)
    x |= (1 << (bits - 1))
    x |= 1
    return x

def generate_prime(bits: int) -> int:
    while True:
        c = _random_odd_integer(bits)
        if _is_probable_prime(c):
            return c

# Task 1: RSA
def generate_rsa_keypair(bits: int = RSA_BITS) -> Tuple[Dict[str, int], Dict[str, int]]:
    if bits < 1024:
        raise ValueError("Use >= 1024 bits for RSA.")
    half = bits // 2
    p = generate_prime(half)
    q = generate_prime(half)
    while q == p:
        q = generate_prime(half)
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 65537
    if phi % e == 0:
        return generate_rsa_keypair(bits)
    d = modinv(e, phi)
    return {"n": n, "e": e}, {"n": n, "d": d}

def hash_message(m: bytes) -> int:
    return int.from_bytes(hashlib.sha256(m).digest(), "big")

def sign(m: bytes, priv: Dict[str, int]) -> int:
    h = hash_message(m)
    n, d = priv["n"], priv["d"]
    if h >= n:
        raise ValueError("Hash >= modulus; use larger RSA key.")
    return pow(h, d, n)

def verify(m: bytes, sig: int, pub: Dict[str, int]) -> int:
    n, e = pub["n"], pub["e"]
    return 1 if pow(sig, e, n) == hash_message(m) else 0


# Task 2: Diffie–Hellman
def generate_safe_prime(bits: int) -> Tuple[int, int]:
    q_bits = bits - 1
    while True:
        q = generate_prime(q_bits)
        p = 2*q + 1
        if _is_probable_prime(p):
            return p, q

def dh_params_fast(bits: int) -> Tuple[int, int]:
    while True:
        p = generate_prime(bits)
        g = 2
        if pow(g, (p - 1) // 2, p) != 1:
            return p, g

def dh_generate_secret(p_or_q: int) -> int:
    while True:
        a = int.from_bytes(secrets.token_bytes(32), "big")
        a %= (p_or_q - 3)
        a += 2
        if 2 <= a <= p_or_q - 1:
            return a

def dh_public(g: int, a: int, p: int) -> int:
    return pow(g, a, p)

def dh_shared(peer_pub: int, my_secret: int, p: int) -> int:
    return pow(peer_pub, my_secret, p)

# Signing helpers to bind parameters (without these, the signing and verification may fail)
def serialize_int(x: int) -> bytes:
    if x == 0: return b"\x00"
    L = (x.bit_length() + 7) // 8
    return x.to_bytes(L, "big")

def bind_values(*ints: int) -> bytes:
    out = bytearray()
    for v in ints:
        b = serialize_int(v)
        out += len(b).to_bytes(4, "big") + b
    return bytes(out)


# Task 3: Key Derivation (KDF)
def kdf_hash_repeat(shared_secret: int, iterations: int = 10000) -> bytes:
    data = serialize_int(shared_secret)      
    for _ in range(iterations):
        data = hashlib.new('sha256', data).digest()
    return data



# Task 4: Pseudo-Random Number Generator (PRNG)
class SimplePRNG:

    def __init__(self, seed_value: int | bytes | None = None):
        if seed_value is None:
            # Default seed
            seed_value = time.time_ns()
        self.seed(seed_value)

    @staticmethod
    def _as_bytes(x: int | bytes | bytearray) -> bytes:
        if isinstance(x, (bytes, bytearray)):
            return bytes(x)
        # int → minimal big-endian bytes
        if x == 0:
            return b"\x00"
        L = (x.bit_length() + 7) // 8
        return x.to_bytes(L, "big")

    def seed(self, seed_value: int | bytes):
        s = self._as_bytes(seed_value)
        self._key = hashlib.sha256(s).digest()
        self._ctr = 0

    def reseed(self, extra: int | bytes):
        e = self._as_bytes(extra)
        self._key = hashlib.sha256(self._key + e).digest()

    def generate(self, n: int) -> bytes:
        out = bytearray()
        while len(out) < n:
            block = hashlib.sha256(self._key + self._ctr.to_bytes(8, "big")).digest()
            out.extend(block)
            self._ctr += 1
        return bytes(out[:n])

# Task 5: Authenticated Encryption (Encrypt-then-MAC)
def derive_subkeys(master_key: bytes) -> tuple[bytes, bytes]:
    return master_key, master_key  

def xor_bytes(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def sha256_ctr_keystream(key: bytes, nonce: bytes, length: int) -> bytes:
   
    out = bytearray()
    ctr = 0
    while len(out) < length:
        block = hashlib.sha256(key + nonce + ctr.to_bytes(8, "big")).digest()
        out.extend(block)
        ctr += 1
    return bytes(out[:length])

def sym_enc(session_key: bytes, prng: "SimplePRNG", plaintext: bytes) -> tuple[bytes, bytes, bytes]:
    K_enc, K_mac = derive_subkeys(session_key)
    nonce = prng.generate(12)                          # IV from Task 4 PRNG
    keystream = sha256_ctr_keystream(K_enc, nonce, len(plaintext))
    ciphertext = xor_bytes(plaintext, keystream)
    tag = hmac.new(K_mac, nonce + ciphertext, hashlib.sha256).digest()
    return nonce, ciphertext, tag

def sym_dec(session_key: bytes, nonce: bytes, ciphertext: bytes, tag: bytes) -> bytes | None:
    K_enc, K_mac = derive_subkeys(session_key)
    expected = hmac.new(K_mac, nonce + ciphertext, hashlib.sha256).digest()
    if not hmac.compare_digest(expected, tag):
        return None
    keystream = sha256_ctr_keystream(K_enc, nonce, len(ciphertext))
    return xor_bytes(ciphertext, keystream)


# Testing and demonstration code
# if __name__ == "__main__":
#     print("Task 1 Demo: RSA keypairs")
#     alice_pub, alice_priv = generate_rsa_keypair(RSA_BITS)
#     bob_pub,   bob_priv   = generate_rsa_keypair(RSA_BITS)

#     print("\n--- Alice Public Key ---")
#     print(f"n (bits) = {alice_pub['n'].bit_length()}")
#     print(f"e        = {alice_pub['e']}")
#     print(f"n (hex):     = {hex(alice_pub['n'])}")

#     print("\n--- Bob Public Key ---")
#     print(f"n (bits) = {bob_pub['n'].bit_length()}")
#     print(f"e        = {bob_pub['e']}")
#     print(f"n (hex):     = {hex(bob_pub['n'])}")

#     msg = b"Hello from Alice. Task 1 signature test."
#     sig = sign(msg, alice_priv)
#     print("\nVerify with Alice pub (expect 1):", verify(msg, sig, alice_pub))
#     print("Verify with Bob   pub (expect 0):", verify(msg, sig, bob_pub))

#     print("\nTask 2: Diffie–Hellman parameters")
    
#     p, g = dh_params_fast(DH_BITS)
#     secret_space = p

#     print(f"p (bits) = {p.bit_length()}")
#     print(f"p        = {p}")
#     print(f"g        = {g}")

#     print("\n--- Alice: pick a, A = g^a mod p, sign over (p||g||A) ---")
#     a = dh_generate_secret(p)
#     A = dh_public(g, a, p)
#     payload_A = bind_values(p, g, A)
#     sigA = sign(payload_A, alice_priv)
#     print(f"A = {A}")
#     print(f"sig(A) = {sigA}")

#     print("\n--- Bob: pick b, B = g^b mod p, sign over (p||g||B) ---")
#     b = dh_generate_secret(p)
#     B = dh_public(g, b, p)
#     payload_B = bind_values(p, g, B)
#     sigB = sign(payload_B, bob_priv)
#     print(f"B = {B}")
#     print(f"sig(B) = {sigB}")

#     print("\n--- Verify signatures ---")
#     print("Alice checks (B,sigB) with Bob's pub:",
#           verify(payload_B, sigB, bob_pub) == 1)
#     print("Bob   checks (A,sigA) with Alice's pub:",
#           verify(payload_A, sigA, alice_pub) == 1)

#     print("\n--- Shared secret ---")
#     S_alice = dh_shared(B, a, p)
#     S_bob   = dh_shared(A, b, p)
#     print(f"S (Alice) = {S_alice}")
#     print(f"S (Bob)   = {S_bob}")
#     print("Shared secret matches?", S_alice == S_bob)


#     iterations = 10_000  # per assignment
#     K_alice = kdf_hash_repeat(S_alice, iterations)
#     K_bob   = kdf_hash_repeat(S_bob, iterations)

#     print("\nTask 3: Encryption Key Derivation (KDF)")
#     print(f"iterations = {iterations}")
#     print(f"K (Alice) = {K_alice.hex()}")
#     print(f"K (Bob)   = {K_bob.hex()}")
#     print("Derived keys match?", K_alice == K_bob)

#     print("\nTask 4: Pseudo-Random Number Generator (PRNG)")

#     # Random-looking sequence (deterministic given the seed)
#     prng1 = SimplePRNG(123456789)
#     seq1 = [prng1.generate(8).hex() for _ in range(5)]
#     print("Seed = 123456789")
#     print("Sequence 1:", seq1)

#     # Determinism: same seed = identical output
#     prng2 = SimplePRNG(123456789)
#     seq2 = [prng2.generate(8).hex() for _ in range(5)]
#     print("\nSame Seed = 123456789")
#     print("Sequence 2 (should match):", seq2)
#     print("Sequences equal?", seq1 == seq2)

#     # reseeding impact: different seed = different output
#     prng2.reseed(987654321)  # mix in new entropy
#     seq3 = [prng2.generate(8).hex() for _ in range(5)]
#     print("\nDifferent Seed = 987654321")
#     print("Sequence 3 (should differ):", seq3)

#     # === Task 5: Authenticated Encryption (Encrypt-then-MAC) ===
#     print("\nTask 5: Authenticated Encryption (Encrypt-then-MAC) Demo")

#     # Use Task 4 PRNG to generate the nonce/IV (assignment requirement)
#     prng5 = SimplePRNG(b"task5-iv-seed")  # fixed seed for reproducible screenshots

#     # Simple message and optional associated data (AAD is authenticated, not encrypted)
#     plaintext = b"Meet me at 10:30 by the library steps."
  

#     # ---------------------------
#     # Alice's terminal (sender)
#     # ---------------------------
#     print("\n[ ALICE ] Inputs to sym_enc:")
#     print("  plaintext =", plaintext)
 
#     print("  prng-seed = b'task5-iv-seed'")

#     # Authenticated Encryption (EtM): nonce, ciphertext, tag
#     nonce, ciphertext, tag = sym_enc(K_alice, prng5, plaintext)

#     # Show sym_enc output (ciphertext)
#     print("\n[ ALICE ] sym_enc output:")
#     print("  nonce      =", nonce.hex())
#     print("  ciphertext =", ciphertext.hex())

#     # Inputs to HMAC (must include ciphertext, not plaintext): nonce || ciphertext
#     import hmac
#     hmac_input = nonce + ciphertext
#     tag_check = hmac.new(K_alice, hmac_input, hashlib.sha256).digest()
#     print("\n[ ALICE ] HMAC inputs & output:")
#     print("  HMAC input (nonce || ciphertext) =", hmac_input.hex())
#     print("  HMAC output (tag)                   =", tag_check.hex())
#     print("  Tag matches sym_enc tag?            =", hmac.compare_digest(tag_check, tag))

#     # Authenticated-Encryption final output is concatenation of the two items above:
#     # (nonce||ciphertext)  and  tag
#     ae_payload = nonce + ciphertext          # what we treat as "ciphertext" to send
#     ae_output  = ae_payload + tag            # full packet sent over the wire
#     print("\n[ ALICE ] Authenticated-Encryption output = (nonce||ciphertext) || tag")
#     print("  nonce||ciphertext =", ae_payload.hex())
#     print("  tag               =", tag.hex())
#     print("  full packet       =", ae_output.hex())

#     # ---------------------------
#     # Bob's terminal (receiver)
#     # ---------------------------
#     print("\n[  BOB  ] Received from Alice:")
#     print("  nonce      =", nonce.hex())
#     print("  ciphertext =", ciphertext.hex())
#     print("  tag        =", tag.hex())

#     # Bob computes the corresponding HMAC and compares with Alice's tag
#     expected_tag = hmac.new(K_bob, nonce + ciphertext, hashlib.sha256).digest()
#     print("\n[  BOB  ] HMAC recompute & compare:")
#     print("  recomputed tag    =", expected_tag.hex())
#     print("  tags match?       =", hmac.compare_digest(expected_tag, tag))

#     # Bob decrypts the received ciphertext and reads the message
#     recovered = sym_dec(K_bob, nonce, ciphertext, tag)
#     print("\n[  BOB  ] Decryption result:", recovered)
#     print("Decryption OK?", recovered == plaintext)

#     #Task 6: Tampering experiment (Optional)
#     print("\nTask 6: Tampering Experiment — ciphertext flip & detection")
#     # We reuse K_bob, aad, and the (nonce, ciphertext, tag) produced in Task 5 above.
#     # Show original wire items (for screenshots)
#     print("[ ALICE ] Original packet (to send):")
#     print("  nonce      =", nonce.hex())
#     print("  ciphertext =", ciphertext.hex())
#     print("  tag        =", tag.hex())

#     # Tamper the ciphertext: flip 1 bit
#     tampered_ct = bytearray(ciphertext)
#     if tampered_ct:
#         tampered_ct[0] ^= 0x01
#     tampered_ct = bytes(tampered_ct)

#     print("\n[ MALLORY ] Tampered packet:")
#     print("  tampered ciphertext =", tampered_ct.hex())
#     print("  (nonce unchanged; tag unchanged)")

#     # Bob's terminal (receiver)
#     print("\n[  BOB  ] Verifies & (tries to) decrypt the tampered packet")

#     # Recompute HMAC on Bob's side to show mismatch
#     Kenc_B, Kmac_B = derive_subkeys(K_bob)
#     recomputed_tag = hmac.new(Kmac_B, nonce + tampered_ct, hashlib.sha256).digest()
#     print("  recomputed tag =", recomputed_tag.hex())
#     print("  tags match?    =", hmac.compare_digest(recomputed_tag, tag))

#     # Attempt to decrypt (EtM does verify-then-decrypt)
#     recovered_tampered = sym_dec(K_bob, nonce, tampered_ct, tag)
#     print("  sym_dec result =", recovered_tampered)
#     print("  decryption failed (expected)?", recovered_tampered is None)

